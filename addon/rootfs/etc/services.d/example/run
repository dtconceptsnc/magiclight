#!/usr/bin/with-contenv bashio
# ==============================================================================
# Start the Home Assistant WebSocket listener
# s6-overlay docs: https://github.com/just-containers/s6-overlay
# ==============================================================================

# ---------------------------------------------------------------
# 0. Ensure MagicLight integration files are installed
# ---------------------------------------------------------------
MAGICLIGHT_SOURCE="/opt/magiclight/custom_components/magiclight"
MAGICLIGHT_DEST_BASE="/config/custom_components"
MAGICLIGHT_DEST=""
MAGICLIGHT_MARKER=""
MAGICLIGHT_REPOSITORY_INFO="/opt/magiclight/repository.yaml"
MAGICLIGHT_BLUEPRINT_SOURCE_BASE="${MAGICLIGHT_BLUEPRINT_SOURCE_BASE:-/opt/magiclight/blueprints}"
export MAGICLIGHT_BLUEPRINT_SOURCE_BASE

normalize_bool() {
    local raw="$1"
    if [ -z "${raw}" ] || [ "${raw}" = "null" ]; then
        raw="true"
    fi

    raw="$(echo "${raw}" | tr '[:upper:]' '[:lower:]')"

    case "${raw}" in
        true|1|yes|on)
            echo "true"
            ;;
        false|0|no|off)
            echo "false"
            ;;
        *)
            echo "true"
            ;;
    esac
}

MANAGE_MAGICLIGHT_INTEGRATION="$(normalize_bool "$(bashio::config 'manage_integration')")"
export MANAGE_MAGICLIGHT_INTEGRATION

MANAGE_MAGICLIGHT_BLUEPRINTS="$(normalize_bool "$(bashio::config 'manage_blueprints')")"
export MANAGE_MAGICLIGHT_BLUEPRINTS

build_default_download_url() {
    local repo_url repo branch

    repo_url="$(awk -F"'" '/^[[:space:]]*url:/ {print $2}' "${MAGICLIGHT_REPOSITORY_INFO}" 2>/dev/null)"
    branch="main"

    if [ -z "${repo_url}" ]; then
        repo="dtconceptsnc/magiclight"
    else
        repo="${repo_url#https://github.com/}"
        repo="${repo%.git}"
        repo="${repo#/}"
        repo="${repo%/}"
        if [ -z "${repo}" ]; then
            repo="dtconceptsnc/magiclight"
        fi
    fi

    echo "https://codeload.github.com/${repo}/tar.gz/refs/heads/${branch}"
}

read_manifest_version() {
    local manifest="$1"
    if [ ! -f "${manifest}" ]; then
        return 1
    fi

    python3 - "$manifest" <<'PY'
import json
import sys

path = sys.argv[1]
try:
    with open(path, 'r', encoding='utf-8') as handle:
        data = json.load(handle)
except Exception:
    sys.exit(1)

value = data.get('version')
if isinstance(value, str):
    value = value.strip()
    if value:
        print(value)
PY
}

download_integration_source() {
    local target_path download_url tmp_dir archive_path source_path repo_root blueprint_base

    target_path="$1"
    download_url="$2"

    if [ -z "${download_url}" ]; then
        download_url="$(build_default_download_url)"
    fi

    tmp_dir="$(mktemp -d)"
    archive_path="${tmp_dir}/magiclight.tar.gz"

    bashio::log.info "Downloading MagicLight integration from ${download_url}..."

    if ! curl -sSL -o "${archive_path}" "${download_url}"; then
        bashio::log.error "Failed to download MagicLight integration archive."
        rm -rf "${tmp_dir}"
        return 1
    fi

    if ! tar -xzf "${archive_path}" -C "${tmp_dir}"; then
        bashio::log.error "Failed to extract MagicLight integration archive."
        rm -rf "${tmp_dir}"
        return 1
    fi

    source_path="$(find "${tmp_dir}" -maxdepth 3 -type d -path '*/custom_components/magiclight' | head -n 1)"

    if [ -z "${source_path}" ]; then
        bashio::log.error "Could not locate custom_components/magiclight in downloaded archive."
        rm -rf "${tmp_dir}"
        return 1
    fi

    repo_root="$(dirname "$(dirname "${source_path}")")"

    if [ -e "${target_path}" ]; then
        rm -rf "${target_path}"
    fi

    mkdir -p "$(dirname "${target_path}")"

    if ! mv "${source_path}" "${target_path}"; then
        bashio::log.error "Failed to move integration files into ${target_path}."
        rm -rf "${tmp_dir}"
        return 1
    fi

    blueprint_base="${repo_root}/blueprints"
    if [ -d "${blueprint_base}" ]; then
        mkdir -p "$(dirname "${MAGICLIGHT_BLUEPRINT_SOURCE_BASE}")"
        if rm -rf "${MAGICLIGHT_BLUEPRINT_SOURCE_BASE}" && \
           cp -a "${blueprint_base}" "${MAGICLIGHT_BLUEPRINT_SOURCE_BASE}"; then
            bashio::log.info "Staged blueprints from downloaded archive to ${MAGICLIGHT_BLUEPRINT_SOURCE_BASE}"
        else
            bashio::log.warning "Failed to stage blueprints from downloaded archive."
        fi
    else
        bashio::log.debug "No blueprints directory found in downloaded archive."
    fi

    rm -rf "${tmp_dir}"
    return 0
}

prepare_destination() {
    local base="${MAGICLIGHT_DEST_BASE}"

    if mkdir -p "${base}" 2>/dev/null; then
        bashio::log.info "Ensured Home Assistant custom_components directory at ${base}."
    fi

    MAGICLIGHT_DEST="${base}/magiclight"
    MAGICLIGHT_MARKER="${MAGICLIGHT_DEST}/.managed_by_magiclight_addon"

    bashio::log.info "Using custom_components directory: ${base}"
}

copy_bundled_integration() {
    local target_path

    target_path="$1"

    if [ ! -d "${MAGICLIGHT_SOURCE}" ]; then
        return 1
    fi

    if [ -e "${target_path}" ]; then
        rm -rf "${target_path}"
    fi

    mkdir -p "$(dirname "${target_path}")"

    if ! cp -a "${MAGICLIGHT_SOURCE}" "${target_path}"; then
        return 1
    fi

    return 0
}

manage_magiclight_integration() {
    local download_url expected_source current_source current_version addon_version

    if [ "${MANAGE_MAGICLIGHT_INTEGRATION}" = "false" ]; then
        if bashio::fs.directory_exists "${MAGICLIGHT_DEST}" && [ -f "${MAGICLIGHT_MARKER}" ]; then
            bashio::log.info "Removing MagicLight integration installed by the add-on..."
            rm -rf "${MAGICLIGHT_DEST}"
        else
            bashio::log.info "Skipping MagicLight integration management (disabled in options)."
        fi
        return
    fi

    prepare_destination

    addon_version="$(bashio::addon.version)"

    download_url="$(bashio::config 'integration_download_url')"
    if [ "${download_url}" = "null" ]; then
        download_url=""
    fi

    if [ -n "${download_url}" ]; then
        expected_source="${download_url}"
    elif [ -d "${MAGICLIGHT_SOURCE}" ]; then
        expected_source="bundled"
    else
        expected_source="$(build_default_download_url)"
    fi

    if [ -f "${MAGICLIGHT_MARKER}" ]; then
        current_source=$(sed -n 's/^source=//p' "${MAGICLIGHT_MARKER}")
        current_version=$(sed -n 's/^addon_version=//p' "${MAGICLIGHT_MARKER}")
        current_integration_version=$(sed -n 's/^integration_version=//p' "${MAGICLIGHT_MARKER}")
    else
        current_source=""
        current_version=""
        current_integration_version=""
    fi

    expected_integration_version=""
    if [ "${expected_source}" = "bundled" ] && [ -f "${MAGICLIGHT_SOURCE}/manifest.json" ]; then
        expected_integration_version=$(read_manifest_version "${MAGICLIGHT_SOURCE}/manifest.json" || echo "")
    fi

    dest_manifest_version=""
    if [ -f "${MAGICLIGHT_DEST}/manifest.json" ]; then
        dest_manifest_version=$(read_manifest_version "${MAGICLIGHT_DEST}/manifest.json" || echo "")
    fi

    integration_versions_match="false"
    if [ -z "${expected_integration_version}" ]; then
        if [ -n "${dest_manifest_version}" ] && [ "${current_integration_version}" = "${dest_manifest_version}" ]; then
            integration_versions_match="true"
        elif [ -z "${dest_manifest_version}" ] && [ -z "${current_integration_version}" ]; then
            integration_versions_match="true"
        fi
    else
        if [ "${current_integration_version}" = "${expected_integration_version}" ] && \
           [ "${dest_manifest_version}" = "${expected_integration_version}" ]; then
            integration_versions_match="true"
        fi
    fi

    if bashio::fs.directory_exists "${MAGICLIGHT_DEST}" && \
        [ "${current_source}" = "${expected_source}" ] && \
        [ "${integration_versions_match}" = "true" ]; then
        bashio::log.info "MagicLight integration already up to date (source: ${expected_source})."
        if [ -n "${MAGICLIGHT_FALLBACK_BASE:-}" ] && \
           [ -d "${MAGICLIGHT_FALLBACK_BASE}/magiclight" ]; then
            bashio::log.info "Mirror already present at ${MAGICLIGHT_FALLBACK_BASE}/magiclight."
        fi
        return
    fi

    if bashio::fs.directory_exists "${MAGICLIGHT_DEST}"; then
        if [ -f "${MAGICLIGHT_MARKER}" ]; then
            bashio::log.info "Updating existing MagicLight integration managed by the add-on..."
        else
            bashio::log.warning "MagicLight integration already present; replacing with managed copy."
        fi
        rm -rf "${MAGICLIGHT_DEST}"
    else
        bashio::log.info "Installing MagicLight custom integration..."
    fi

    if [ -n "${download_url}" ]; then
        if ! download_integration_source "${MAGICLIGHT_DEST}" "${download_url}"; then
            bashio::log.error "Unable to deploy MagicLight integration from ${download_url}."
            return
        fi
    elif [ -d "${MAGICLIGHT_SOURCE}" ]; then
        bashio::log.info "Copying MagicLight integration bundled with the add-on..."
        if ! copy_bundled_integration "${MAGICLIGHT_DEST}"; then
            bashio::log.error "Bundled MagicLight integration missing; attempting download instead."
            if ! download_integration_source "${MAGICLIGHT_DEST}" ""; then
                bashio::log.error "Unable to deploy MagicLight integration."
                return
            fi
        fi
    else
        bashio::log.info "Downloading MagicLight integration from main branch..."
        if ! download_integration_source "${MAGICLIGHT_DEST}" ""; then
            bashio::log.error "Unable to deploy MagicLight integration."
            return
        fi
    fi

    {
        echo "addon_version=${addon_version}"
        integration_version=$(read_manifest_version "${MAGICLIGHT_DEST}/manifest.json" || echo "")
        echo "integration_version=${integration_version}"
        echo "source=${expected_source}"
        echo "updated_at=$(date -Iseconds)"
    } > "${MAGICLIGHT_MARKER}"

    if ! bashio::fs.directory_exists "${MAGICLIGHT_DEST}"; then
        bashio::log.error "MagicLight integration deployment failed; destination not found after copy."
        return
    fi

    if [ ! -f "${MAGICLIGHT_DEST}/manifest.json" ]; then
        bashio::log.warning "MagicLight integration manifest not found at ${MAGICLIGHT_DEST}/manifest.json."
        bashio::log.warning "Directory contents: $(ls -A "${MAGICLIGHT_DEST}" 2>/dev/null || echo '(empty)')"
    else
        bashio::log.info "MagicLight integration manifest detected at ${MAGICLIGHT_DEST}/manifest.json."
    fi

    bashio::log.info "MagicLight integration deployed to ${MAGICLIGHT_DEST}."

    if [ -n "${SUPERVISOR_TOKEN:-}" ]; then
        discovery_payload='{"service":"magiclight","config":{}}'
        bashio::log.info "Publishing discovery payload to supervisor..."
        if curl -sS -X POST "http://supervisor/addons/self/discovery" \
            -H "Authorization: Bearer ${SUPERVISOR_TOKEN}" \
            -H "Content-Type: application/json" \
            -d "${discovery_payload}" >/dev/null; then
            bashio::log.info "Supervisor discovery payload sent successfully."
        else
            bashio::log.warning "Failed to send supervisor discovery payload."
        fi
    fi
}

if [ "${MAGICLIGHT_SKIP_MAIN:-}" = "1" ]; then
    return 0 2>/dev/null || exit 0
fi

manage_magiclight_integration

# ---------------------------------------------------------------
# 1. Detect mode
#    - If SUPERVISOR_TOKEN is present → ADDON
#    - Else → STANDALONE
# ---------------------------------------------------------------
if [ -z "${SUPERVISOR_TOKEN:-}" ] && [ -n "${SUPERVISOR_TOKEN_FILE:-}" ] && [ -f "${SUPERVISOR_TOKEN_FILE}" ]; then
    SUPERVISOR_TOKEN="$(cat "${SUPERVISOR_TOKEN_FILE}")"
fi

if [ -n "${SUPERVISOR_TOKEN:-}" ]; then
    MODE="ADDON"
    bashio::log.info "Running in addon mode (SUPERVISOR_TOKEN present)"
    
    # In addon mode, use supervisor proxy URLs
    export HA_WEBSOCKET_URL="ws://supervisor/core/api/websocket"
    export HA_REST_URL="http://supervisor/core/api"
    export HA_TOKEN="${SUPERVISOR_TOKEN}"
    
    # These are not used in URL mode but kept for compatibility
    export HA_HOST="supervisor"
    export HA_PORT="80"
    export HA_USE_SSL="false"
else
    MODE="STANDALONE"
    bashio::log.info "Running in standalone mode (no supervisor token)"
    
    # Try to get config from bashio first, then fall back to env vars
    CONFIG_HOST=$(bashio::config 'host')
    CONFIG_PORT=$(bashio::config 'port')
    CONFIG_TOKEN=$(bashio::config 'token')
    CONFIG_USE_SSL=$(bashio::config 'use_ssl')
    
    # Set host
    if [ "${CONFIG_HOST}" != "null" ] && [ -n "${CONFIG_HOST}" ]; then
        export HA_HOST="${CONFIG_HOST}"
    else
        export HA_HOST="${HA_HOST:-localhost}"
    fi
    
    # Set port
    if [ "${CONFIG_PORT}" != "null" ] && [ -n "${CONFIG_PORT}" ]; then
        export HA_PORT="${CONFIG_PORT}"
    else
        export HA_PORT="${HA_PORT:-8123}"
    fi
    
    # Set token
    if [ "${CONFIG_TOKEN}" != "null" ] && [ -n "${CONFIG_TOKEN}" ]; then
        export HA_TOKEN="${CONFIG_TOKEN}"
    else
        export HA_TOKEN="${HA_TOKEN:-}"
    fi
    
    # Set SSL
    if [ "${CONFIG_USE_SSL}" != "null" ] && [ -n "${CONFIG_USE_SSL}" ]; then
        export HA_USE_SSL="${CONFIG_USE_SSL}"
    else
        export HA_USE_SSL="${HA_USE_SSL:-false}"
    fi
    
    # Build WebSocket URL
    if [ "${HA_USE_SSL}" = "true" ]; then
        export HA_WEBSOCKET_URL="wss://${HA_HOST}:${HA_PORT}/api/websocket"
    else
        export HA_WEBSOCKET_URL="ws://${HA_HOST}:${HA_PORT}/api/websocket"
    fi
fi

# Check if token is set
if [ -z "${HA_TOKEN:-}" ]; then
    bashio::log.error "No Home Assistant token provided!"
    bashio::log.info "Set token in addon configuration or HA_TOKEN environment variable"
    exit 1
fi

# Log startup
bashio::log.info "Starting Home Assistant WebSocket listener..."
bashio::log.info "Mode: ${MODE}"
bashio::log.info "WebSocket URL: ${HA_WEBSOCKET_URL}"

# Determine where the designer persists configuration (mirrors webserver.py)
DATA_DIR="/data"
if [ ! -d "${DATA_DIR}" ]; then
    DATA_DIR="/app/.data"
fi
DESIGNER_CONFIG_PATH="${DATA_DIR}/designer_config.json"
OPTIONS_JSON_PATH="${DATA_DIR}/options.json"

read_color_mode_from_file() {
    local path="$1"
    if [ -f "${path}" ]; then
        python3 - "${path}" <<'PY'
import json
import sys

path = sys.argv[1]
try:
    with open(path, 'r', encoding='utf-8') as handle:
        data = json.load(handle)
except Exception:
    sys.exit(0)

value = data.get('color_mode') if isinstance(data, dict) else None
if isinstance(value, str):
    value = value.strip()
    if value:
        print(value)
PY
    fi
}

# Prefer designer setting, then legacy supervisor options, then defaults
COLOR_MODE_SOURCE=""
COLOR_MODE=$(read_color_mode_from_file "${DESIGNER_CONFIG_PATH}")
if [ -n "${COLOR_MODE}" ]; then
    COLOR_MODE_SOURCE="designer_config"
else
    COLOR_MODE=$(read_color_mode_from_file "${OPTIONS_JSON_PATH}")
    if [ -n "${COLOR_MODE}" ]; then
        COLOR_MODE_SOURCE="options_json"
    fi
fi

if [ -z "${COLOR_MODE}" ] || [ "${COLOR_MODE}" = "null" ]; then
    COLOR_MODE="kelvin"
    COLOR_MODE_SOURCE="default"
fi

COLOR_MODE=$(echo "${COLOR_MODE}" | tr '[:upper:]' '[:lower:]')
case "${COLOR_MODE}" in
    kelvin|rgb|xy)
        ;;
    *)
        bashio::log.warning "Invalid color mode '${COLOR_MODE}' detected; defaulting to kelvin."
        COLOR_MODE="kelvin"
        COLOR_MODE_SOURCE="default"
        ;;
esac

export COLOR_MODE="${COLOR_MODE}"

case "${COLOR_MODE_SOURCE}" in
    designer_config)
        bashio::log.info "Loaded color mode from designer configuration (${COLOR_MODE})."
        ;;
    options_json)
        bashio::log.warning "Using legacy color mode from options.json (${COLOR_MODE}); please save from the designer UI to migrate."
        ;;
    *)
        bashio::log.info "Using default color mode (${COLOR_MODE})."
        ;;
esac

# Get min_color_temp configuration
MIN_COLOR_TEMP=$(bashio::config 'min_color_temp')
if [ "${MIN_COLOR_TEMP}" != "null" ] && [ -n "${MIN_COLOR_TEMP}" ]; then
    export MIN_COLOR_TEMP="${MIN_COLOR_TEMP}"
else
    export MIN_COLOR_TEMP="500"
fi

# Get max_color_temp configuration
MAX_COLOR_TEMP=$(bashio::config 'max_color_temp')
if [ "${MAX_COLOR_TEMP}" != "null" ] && [ -n "${MAX_COLOR_TEMP}" ]; then
    export MAX_COLOR_TEMP="${MAX_COLOR_TEMP}"
else
    export MAX_COLOR_TEMP="6500"
fi

bashio::log.info "Color mode: ${COLOR_MODE}"
bashio::log.info "Color temperature range: ${MIN_COLOR_TEMP}K - ${MAX_COLOR_TEMP}K"

# Set ingress port for web server
export INGRESS_PORT="8099"
bashio::log.info "Ingress port: ${INGRESS_PORT}"

# Start the web server in background
bashio::log.info "Starting Light Designer web server..."
cd /app
python3 webserver.py &
WEBSERVER_PID=$!
bashio::log.info "Web server started with PID ${WEBSERVER_PID}"

# Give the web server a moment to start
sleep 2

# Run the main Python app
bashio::log.info "Starting main application..."
exec python3 main.py
